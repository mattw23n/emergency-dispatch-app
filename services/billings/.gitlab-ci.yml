stages:
  - Static Analysis
  - Security Testing
  - Test
  - Smoke Test
  - Release
  - Deploy

flake8:
  stage: Static Analysis
  image: python:3.12-slim
  before_script:
    - python -V
    - python -m pip install flake8
  script:
    - flake8 src | tee flake8_report.txt
  artifacts:
    when: on_failure
    paths:
      - flake8_report.txt

pylint:
  stage: Static Analysis
  image: python:3.12-slim
  before_script:
    - python -V
    - python -m pip install -r requirements.txt
    - python -m pip install pylint
  script:
    - pylint --fail-under=7 src | tee pylint_report.txt
  artifacts:
    when: always
    paths:
      - pylint_report.txt

semgrep:
  stage: Security Testing
  image: returntocorp/semgrep
  script: ["semgrep ci --config p/owasp-top-ten"]

trivy:
  stage: Security Testing
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]     # override entrypoint so we call trivy directly
  script: ["trivy fs --severity CRITICAL,HIGH ."]

gitleaks:
  stage: Security Testing
  image:
    name: zricethezav/gitleaks:latest
    entrypoint: [""]  # override entrypoint so we call gitleaks directly
  script: ["gitleaks detect --source . --no-git -v"]

unit-tests:
  stage: Test
  image: python:3.13-slim
  before_script:
    - python -V
    - python -m pip install -r requirements.txt
    - python -m pip install pytest pytest-cov
  script:
    - python -m pytest tests/test_unit.py -v --cov=src --cov-report=xml
  artifacts:
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
  coverage: '/^TOTAL\s+\d+\s+\d+\s+(\d+\.\d+)%$/'

integration-tests:
  stage: Test
  image: docker:28.3.2
  services:
    - docker:28.3.2-dind
  before_script:
    - docker info
  script:
    - docker compose -f ci/compose.test.yaml up --exit-code-from billings-pytest

build-image:
  stage: Smoke Test
  image: docker:28.3.2
  services:
    - docker:28.3.2-dind
  before_script:
    - docker info
  script:
    # Build the image with both tags
    - docker build --pull -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:latest" -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:$CI_COMMIT_SHA" .
    # Save image metadata for next stage
    - echo "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:$CI_COMMIT_SHA" > image_name.txt
  artifacts:
    paths:
      - image_name.txt
    expire_in: 20 min

smoke-test-image:
  stage: Smoke Test
  image: docker:28.3.2
  services:
    - docker:28.3.2-dind
  needs:
    - build-image
  before_script:
    - apk add --no-cache curl
    - docker info
  script:
    # Rebuild image from cache (fast since layers exist)
    - docker build -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:$CI_COMMIT_SHA" .
    
    # Create a dedicated network for the smoke test
    - docker network create billings-test-network
    
    # Start MySQL database container
    - |
      docker run -d --name mysql-test \
        --network billings-test-network \
        -e MYSQL_ROOT_PASSWORD=root \
        -e MYSQL_DATABASE=billings \
        -e MYSQL_USER=billings \
        -e MYSQL_PASSWORD=billings123 \
        mysql:8.0
    
    # Start RabbitMQ container
    - |
      docker run -d --name rabbitmq-test \
        --network billings-test-network \
        -e RABBITMQ_DEFAULT_USER=guest \
        -e RABBITMQ_DEFAULT_PASS=guest \
        rabbitmq:3.13-management-alpine
    
    # Wait for MySQL to be ready
    - echo "Waiting for MySQL to start..."
    - sleep 20
    - docker exec mysql-test mysqladmin ping -h localhost -u root -proot --silent || (echo "MySQL not ready" && docker logs mysql-test && exit 1)
    
    # Create billings table in the database
    - |
      docker exec mysql-test mysql -u root -proot billings -e "
      CREATE TABLE IF NOT EXISTS billings (
        billing_id INT AUTO_INCREMENT PRIMARY KEY,
        incident_id VARCHAR(50) NOT NULL,
        patient_id VARCHAR(50) NOT NULL,
        amount DECIMAL(10, 2) NOT NULL,
        status VARCHAR(50) DEFAULT 'pending',
        insurance_verified BOOLEAN DEFAULT FALSE,
        payment_status VARCHAR(50) DEFAULT 'pending',
        stripe_payment_intent_id VARCHAR(255),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        INDEX idx_incident_id (incident_id),
        INDEX idx_patient_id (patient_id)
      );"
    
    # Wait for RabbitMQ to be ready
    - echo "Waiting for RabbitMQ to start..."
    - sleep 15

    # Run billings container connected to the same network
    - |
      docker run -d --name billings-test \
        --network billings-test-network \
        -p 5100:5100 \
        -e db_conn=mysql+mysqlconnector://root:root@mysql-test:3306/billings \
        -e INSURANCE_API_URL=http://mock-insurance:5200/insurance/verify \
        -e RABBITMQ_HOST=rabbitmq-test \
        -e RABBITMQ_PORT=5672 \
        -e RABBITMQ_USER=guest \
        -e RABBITMQ_PASSWORD=guest \
        -e RABBITMQ_VHOST=/ \
        -e AMQP_EXCHANGE_NAME=amqp.topic \
        -e AMQP_EXCHANGE_TYPE=topic \
        -e STRIPE_SECRET_KEY=sk_test_fake_key_for_smoke_test \
        -e STRIPE_PUBLIC_KEY=pk_test_fake_key_for_smoke_test \
        -e PYTHONUNBUFFERED=1 \
        -e FLASK_DEBUG=false \
        "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:$CI_COMMIT_SHA"
    
    # Wait for Flask app to start and connect to dependencies
    - echo "Waiting for billings service to start..."
    - sleep 20
    
    # Check if containers are still running
    - docker ps | grep billings-test || (echo "Billings container crashed!" && docker logs billings-test && exit 1)
    - docker ps | grep mysql-test || (echo "MySQL container crashed!" && docker logs mysql-test && exit 1)
    - docker ps | grep rabbitmq-test || (echo "RabbitMQ container crashed!" && docker logs rabbitmq-test && exit 1)
    
    # Show billings logs to see if Flask started
    - echo "=== Billings startup logs ==="
    - docker logs billings-test 2>&1 | tail -30
    
    # Wait a bit more for Flask to be fully ready
    - echo "Waiting additional time for Flask to be ready..."
    - sleep 10
    
    # Test health endpoint with retries - should return 200
    - |
      MAX_RETRIES=5
      RETRY_COUNT=0
      SUCCESS=0
      
      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
        
        # Use docker exec to curl from inside the billings container
        if docker exec billings-test wget -q -O- http://127.0.0.1:5100/health > /dev/null 2>&1; then
          echo "✓ Health check passed - service is fully operational"
          SUCCESS=1
          break
        fi
        
        RETRY_COUNT=$((RETRY_COUNT + 1))
        if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
          echo "Retrying in 5 seconds..."
          sleep 5
        fi
      done
      
      if [ "$SUCCESS" != "1" ]; then
        echo "✗ Health check failed after $MAX_RETRIES attempts"
        echo "=== Billings logs ==="
        docker logs billings-test
        echo "=== MySQL logs ==="
        docker logs mysql-test
        echo "=== RabbitMQ logs ==="
        docker logs rabbitmq-test
        exit 1
      fi
    
    # Verify the response shows correct service name
    - |
      echo "Verifying health endpoint response..."
      HEALTH_RESPONSE=$(docker exec billings-test wget -q -O- http://127.0.0.1:5100/health)
      echo "Health response: $HEALTH_RESPONSE"
      
      if echo "$HEALTH_RESPONSE" | grep -q '"service":[[:space:]]*"billings"'; then
        echo "✓ Service name confirmed: billings"
      else
        echo "✗ Service name mismatch!"
        exit 1
      fi
      
      if echo "$HEALTH_RESPONSE" | grep -q '"status":[[:space:]]*"ok"'; then
        echo "✓ Service status: ok"
      else
        echo "✗ Service status not ok!"
        exit 1
      fi
      
      echo "✓ Billings service health confirmed"
    
    # Verify RabbitMQ consumer is running (check logs for connection message)
    - |
      echo "Checking RabbitMQ consumer status..."
      docker logs billings-test 2>&1 | grep -q "Connected to RabbitMQ" && echo "RabbitMQ consumer confirmed" || echo "Warning: RabbitMQ consumer status unclear"
    
    # Verify database connection and tables
    - |
      echo "Checking database connection..."
      docker logs billings-test 2>&1 | grep -q "Database tables verified/created successfully" && echo "Database connection confirmed" || echo "Warning: Database initialization unclear"
    
    # Show logs for verification
    - echo "=== Billings logs (last 20 lines) ==="
    - docker logs billings-test 2>&1 | tail -20
    
    # Cleanup
    - docker stop billings-test mysql-test rabbitmq-test || true
    - docker rm billings-test mysql-test rabbitmq-test || true
    - docker network rm billings-test-network || true
  allow_failure: false

# based on: https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/templates/Docker.gitlab-ci.yml
release-image:
  stage: Release
  image: docker:28.3.2
  services:
    - docker:28.3.2-dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:latest" -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:$CI_COMMIT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH" --all-tags

update_gitops_manifest:
  stage: Deploy
  image: alpine:latest
  variables:
    GIT_STRATEGY: none
  before_script:
    - apk add --no-cache git yq
    - git config --global user.email "gitlab-ci@${CI_PROJECT_PATH}.com"
    - git config --global user.name "GitLab CI Bot"
  script:
    - IMAGE_NAME="${CI_REGISTRY_IMAGE}/$CI_COMMIT_BRANCH:${CI_COMMIT_SHA}"

    # Extract the service name from the project name and convert to lowerclass
    - SERVICE_NAME=$(echo "$CI_PROJECT_NAME" | tr '[:upper:]' '[:lower:]')
    - YAML_FILE="${SERVICE_NAME}.yaml"

    # Debugging outputs
    # - echo "Service name= $SERVICE_NAME"
    # - echo "YAML file= $YAML_FILE"

    # Clone k8s repo
    - git clone "https://oauth2:${GITLAB_TOKEN}@gitlab.com/cs302-2025/g2-team5/k8s.git" gitops-repo
    - cd gitops-repo
    - git checkout main

    # Debugging outputs
    # - echo "repo contents:"
    # - ls -la

    # Check if the YAML file exists
    - |
      if [ ! -f "$YAML_FILE" ]; then
        echo "Error: $YAML_FILE not found in k8s repository!"
        echo "Available files:"
        ls -la *.yaml || echo "No YAML files found"
        exit 1
      fi

    - echo "Updating $YAML_FILE with image= $IMAGE_NAME"
    - yq e '(select(.kind == "Deployment") | .spec.template.spec.containers[0].image) = "'$IMAGE_NAME'"' -i "$YAML_FILE"
    - git add "$YAML_FILE"
    - git diff --cached --exit-code || (git commit -m "Update $SERVICE_NAME image to $IMAGE_NAME [skip ci]" && git push origin main)
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  dependencies:
    - release-image


# deploy-ecs:
#   stage: Deploy
#   image: 'registry.gitlab.com/gitlab-org/cloud-deploy/aws-ecs:latest'
#   environment:
#     name: production-ecs
#   rules:
#     - if: '$CI_COMMIT_REF_NAME == "main"'
#   script:
#     - ecs update-task-definition