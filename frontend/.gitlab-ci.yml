# Frontend CI/CD Pipeline
# Purpose: Validate and test frontend code quality
# Note: Frontend is served by api-gateway, not deployed separately
# This pipeline ensures code quality before merging to main branch

stages:
  - Static Analysis
  - Security Testing
  # - Test
  - Release
  - Deploy

html-validate:
  stage: Static Analysis
  image: node:18-alpine
  before_script:
    - npm install -g html-validate
  script:
    - html-validate *.html | tee html_validate_report.txt || echo "HTML validation warnings found"
  artifacts:
    when: always
    paths:
      - html_validate_report.txt
  allow_failure: true

eslint:
  stage: Static Analysis
  image: node:18-alpine
  before_script:
    - npm install -g eslint
  script:
    - eslint --no-eslintrc --env browser,es6 --parser-options ecmaVersion:2020 dashboard.html index.html || echo "ESLint warnings found"
  allow_failure: true

semgrep:
  stage: Security Testing
  image: returntocorp/semgrep
  script: ["semgrep ci --config p/owasp-top-ten"]
  allow_failure: true

trivy:
  stage: Security Testing
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script: ["trivy fs --severity CRITICAL,HIGH ."]

gitleaks:
  stage: Security Testing
  image:
    name: zricethezav/gitleaks:latest
    entrypoint: [""]
  script: ["gitleaks detect --source . --no-git -v"]

# integration-tests:
#   stage: Test
#   image: docker:28.3.2
#   services:
#     - docker:28.3.2-dind
#   before_script:
#     - docker info
#   script:
#     - docker compose -f ci/compose.test.yaml up --exit-code-from frontend-test

release-image:
  stage: Release
  image: docker:28.3.2
  services:
    - docker:28.3.2-dind
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker build --pull -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:latest" -t "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH:$CI_COMMIT_SHA" .
    - docker push "$CI_REGISTRY_IMAGE/$CI_COMMIT_BRANCH" --all-tags
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success

update_gitops_manifest:
  stage: Deploy
  image: alpine:latest
  variables:
    GIT_STRATEGY: none
  before_script:
    - apk add --no-cache git yq
    - git config --global user.email "gitlab-ci@${CI_PROJECT_PATH}.com"
    - git config --global user.name "GitLab CI Bot"
  script:
    - IMAGE_NAME="${CI_REGISTRY_IMAGE}/$CI_COMMIT_BRANCH:${CI_COMMIT_SHA}"

    # Extract the service name from the project name and convert to lowercase
    - SERVICE_NAME=$(echo "$CI_PROJECT_NAME" | tr '[:upper:]' '[:lower:]')
    - YAML_FILE="${SERVICE_NAME}.yaml"

    # Clone k8s repo
    - git clone "https://oauth2:${GITLAB_TOKEN}@gitlab.com/cs302-2025/g2-team5/k8s.git" gitops-repo
    - cd gitops-repo
    - git checkout main

    # Check if the YAML file exists
    - |
      if [ ! -f "$YAML_FILE" ]; then
        echo "Error: $YAML_FILE not found in k8s repository!"
        echo "Available files:"
        ls -la *.yaml || echo "No YAML files found"
        exit 1
      fi

    - echo "Updating $YAML_FILE with image= $IMAGE_NAME"
    - yq e '(select(.kind == "Deployment") | .spec.template.spec.containers[0].image) = "'$IMAGE_NAME'"' -i "$YAML_FILE"
    - git add "$YAML_FILE"
    - git diff --cached --exit-code || (git commit -m "Update $SERVICE_NAME image to $IMAGE_NAME [skip ci]" && git push origin main)
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  dependencies:
    - release-image
